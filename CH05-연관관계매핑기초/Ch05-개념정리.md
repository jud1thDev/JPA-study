객체는 참조(주소)를 사용해서 연관관계를 맺고, 테이블은 외래 키를 사용해 연관관계를 맺는다. JPA가 이 둘을 어떻게 매핑하는 지 알아보자.

- 방향성: 단방향 vs 양방향
- 다중성: 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)
- 양방향 연관관계일 경우, 연관관계의 주인을 명확히 정해야 함

# 5.1 단방향 연관관계

회원과 팀 예제를 통해 [다대일, 단방향] 관계를 살펴보자.

## 5.1.1 순수한 객체 연관관계(JPA x)

먼저 순수한 자바 객체에서의 연관관계 방식부터 살펴보자.

```JAVA
public class Member {

private String id;
private String username;

private Team team;

public void setTeam(final Team team) {
this.team = team;
}

// Getter, Setter ...

}

public class Team {

private String id;
private String name;

// Getter, Setter ...

}
```

```JAVA
// 동작 코드
public static void main(String... args) {
// 생성자(id, 이름)
Member member1 = new Member("member1", "회원1");
Member member2 = new Member("member2", "회원2");
Team team1 = new Team("team1", "팀1");

member1.setTeam(team1);
member2.setTeam(team1);

Team findTeam = member1.getTeam(); // 객체 그래프 탐색
}
```

- 순수 자바 객체로도 연관관계 설정 가능
- **객체 그래프 탐색**:
  - 객체가 참조를 따라가며 연관관계를 탐색하는 것
  - `Team findTeam = member1.getTeam();`
  - 즉 member → team 방향만 가능하며 team → member(`team.getMember()`)는 불가함

<br>

## 5.1.2 테이블 연관관계

```SQL
-- 테이블 구조
MEMBER
- MEMBER_ID (PK)
- TEAM_ID (FK)
- USERNAME

TEAM
- TEAM_ID (PK)
- NAME
```

```SQL
-- 테이블 DDL 
CREATE TABLE member
(
    member_id varchar(255) primary key,
    team_id   varchar(255),
    username  varchar(255),
    CONSTRAINT fk_member_team FOREIGN KEY (team_id) -- 외래 키 설정
        REFERENCES team (team_id)
);

CREATE TABLE team
(
    team_id varchar(255) primary key,
    name varchar(255)
);

-- INSERT SQL
INSERT INTO team VALUES ('team1', '팀1');

INSERT INTO member VALUES ('member1', 'team1', '회원1'),
                          ('member2', 'team1', '회원2');
                        
-- 회원 1이 소속된 팀을 조회하는 SQL
SELECT T.*
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
WHERE M.MEMBER_ID = 'member1';
```

- MEMBER가 TEAM_ID 외래 키를 통해 TEAM과 연관됨
- JOIN을 통해 외래 키 하나로 양방향 조회 가능

<br>

## 5.1.3 객체 관계 매핑 (@ManyToOne, @JoinColumn)

지금까지 객체만 사용한 연관관계와 테이블만 사용한 연관관계를 각각 알아보았으니, 이제 JPA를 사용해서 둘을 매핑해보자.

```JAVA
@Entity
public class Member {

    @Id
    @Column(name = "MEMBER_ID")
    private String id;

    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID") // 외래 키 컬럼 지정
    private Team team;
}
```

```JAVA
@Entity
public class Team {

    @Id
    @Column(name = "TEAM_ID")
    private String id;

    private String name;
}
```

- `@ManyToOne`: 
  - 회원은 하나의 팀에 소속되므로, 다대일 관계임
  - 연관관계를 매핑할 때 이렇게 다중성을 나타내는 애노테이션을 필수로 사용해야 함
- `@JoinColumn(name = "TEAM_ID")`: 
  - 외래 키 컬럼을 지정함
  - 생략 가능함
- 이렇게 매핑하면 JPA가 내부적으로 member.team_id ↔ team.team_id로 연결해서 JOIN을 자동 처리해줌

<br>

## 5.1.4 @JoinColumn 속성 정리

`@JoinColumn`은 외래 키를 어떤 컬럼에 매핑할지 지정하는 어노테이션이다.

| 속성                 | 설명                                                   |
|----------------------|--------------------------------------------------------|
| name                 | 외래 키 컬럼 이름 지정                                 |
| referencedColumnName | 참조 대상 테이블의 기본 키 컬럼명 (기본값은 참조 PK)  |
| foreignKey           | 외래 키 제약조건 명시                                  |
| insertable / updatable | 삽입/수정 가능 여부 설정                           |
| table                | 다중 테이블 매핑 시 사용                               |

> 생략 시 기본값: `필드명 + _ + 참조 PK컬럼명`  
> ex. `team → TEAM_ID`

<br>

## 5.1.5 @ManyToOne 속성 정리

`@ManyToOne`은 객체 간 다대일(N:1) 연관관계를 매핑할 때 사용하는 어노테이션이다.

| 속성         | 설명                                                   |
|--------------|--------------------------------------------------------|
| optional     | `false`로 설정하면 연관된 객체가 반드시 존재해야 함 (NOT NULL) |
| fetch        | 연관된 엔티티 로딩 방식 설정 (`EAGER`: 즉시 로딩, `LAZY`: 지연 로딩) |
| cascade      | 영속성 전이 설정 (예: `CascadeType.PERSIST` 사용 시 부모 저장 시 자식도 저장됨) |
| targetEntity | 연관될 엔티티 타입 명시 (대부분 생략 가능)                   |

> 기본값: `optional = true`, `fetch = EAGER`

<br>
<br>

# 5.2 연관관계 사용

<br>
<br>

# 5.3 양방향 연관관계

<br>
<br>

# 5.6 연관관계의 주인

<br>
<br>

# 5.6 양방향 연관관계 저장
