# 12.1 스프링 데이터 JPA 소개

- JPA를 사용할 때 반복적인 CRUD 코드 문제가 흔히 발생한다
  - 예를 들어, MemberRepository와 ItemRepository 두 클래스가 있는데, 각각 회원, 상품을 저장하고 조회하는 기능이 있다. 실제로 보면 두 클래스는 거의 같은 일을 한다: `save()`, `findOne()`, `findAll()`
  - 중복 코드가 생기고 유지보수가 어려운 문제가 발생한다
- 해결: 제네릭(Generic)과 상속을 사용해서 공통 기능을 처리하는 부모 클래스(일반적으로 GenericDAO)를 각 클래스에서 재사용한다
  - 또다른 문제가 발생한다: 공통 기능을 구현한 부모 클래스에 너무 의존하게 되고, 상속의 단점이 드러날 수 있다
- 이러한 문제를 보다 세련되게 해결하는 방식이 Spring Data JPA이다
  - Spring Data JPA는 Spring 프레임워크에서 JPA를 더 편하게 쓰도록 도와주는 프로젝트이다
  - 반복적인 CRUD 메서드를 미리 정의한 JpaRepository 인터페이스를 상속하기만 하면 된다
  - 직접 구현 없이도 `save()`, `findOne()`, `findAll()` 같은 메서드를 자동으로 제공받을 수 있어 코드가 훨씬 간결해진다
  - 또한 `findByUsername()` 같은 메서드는 이름만 정의해도 JPQL을 자동 생성하여 실행해준다
  ```java
  public interface MemberRepository extends JpaRepository<Member, Long> {
    // 아무것도 안 써도 save(), findById(), findAll() 같은 기본 기능 다 됨
    Member findByUsername(String username); // 메서드명 기반으로 쿼리 자동 생성
  }
  ```

<br>

## 12.1.1 스프링 데이터 프로젝트

- Spring Data는 JPA뿐 아니라 다양한 저장소 연동 기능을 통합적으로 제공한다
- 즉, 여러 저장소에 대한 접근을 일관된 방식으로 처리할 수 있다
- 하위 프로젝트:
  - Spring Data JPA → 스프링 프레임워크와 JPA를 함께 사용한다면 Spring Data JPA 사용을 적극 권장한다!
  - Spring Data MongoDB 
  - Spring Data Redis 
  - Spring Data Neo4j 
  - Spring Data Hadoop, Gemfire 등

<br>
<br>

# 12.2 스프링 데이터 JPA 설정

## 필요 라이브러리
```xml
<dependency>
  <groupId>org.springframework.data</groupId>
  <artifactId>spring-data-jpa</artifactId>
  <version>1.8.0.RELEASE</version> # 책에서의 버전, 나는 2.7.18 버전을 사용했다.
</dependency>
```

- [pom.xml](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fpom.xml)
- 참고: `spring-data-jpa`는 `spring-data-commons`에 의존하므로, `spring-data-jpa`만 추가해도 두 라이브러리가 모두 포함된다.

<br>

## 환경설정

### Java 기반 설정 (현재 프로젝트 적용)
`ch10-jpa-shop` 프로젝트는 Java 설정 방식을 사용합니다.

```java
@Configuration
@EnableJpaRepositories(basePackages = "jpabook.jpashop.repository") // Spring Data JPA Repository 스캔 활성화
public class JpaConfig {
}
```

- [JpaConfig.java](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fsrc%2Fmain%2Fjava%2Fjpabook%2Fjpashop%2Fconfig%2FJpaConfig.java)
- **`@EnableJpaRepositories`**: Spring Data JPA Repository들을 자동으로 스캔하고 등록
- **`basePackages`**: Repository 인터페이스들이 위치한 패키지 경로 지정
- **자동 스캔**: 지정된 패키지와 하위 패키지에서 Repository 인터페이스들을 찾아서 Spring Bean으로 등록

### XML 기반 설정 (참고용)
Spring XML 설정을 사용하는 경우 `<jpa:repositories>` 요소를 사용할 수도 있다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:jpa="http://www.springframework.org/schema/data/jpa"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/data/jpa
                           http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

    <jpa:repositories base-package="jpabook.jpashop.repository" />

</beans>
```

- **`<jpa:repositories>`**: Spring Data JPA Repository들을 자동으로 스캔하고 등록
- **`base-package`**: Repository 인터페이스들이 위치한 패키지 경로 지정
- **설정 방식 비교**:
  - **Java 방식**: `@EnableJpaRepositories` 어노테이션 사용 (권장)
  - **XML 방식**: `<jpa:repositories>` 태그 사용
- **결과**: 두 방식 모두 동일한 Repository 스캔 및 등록 기능 제공

<br>
<br>

# 12.3 공통 인터페이스 기능

## Repository 인터페이스

- Spring Data JPA의 핵심은 Repository 인터페이스
- `JpaRepository<T, ID>`를 상속받으면 기본적인 CRUD 메서드들을 자동으로 제공받음
- T: 엔티티 타입, ID: 엔티티의 식별자 타입, S: 엔티티와 그 자식 타입

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    // JpaRepository가 제공하는 모든 메서드 사용 가능
    // save(), findById(), findAll(), delete(), count() 등
}
```

### JpaRepository 계층 구조
```
Repository (마커 인터페이스)
    ↓
CrudRepository<T, ID> (기본 CRUD 기능)
    ↓
PagingAndSortingRepository<T, ID> (페이징, 정렬 기능)
    ↓
JpaRepository<T, ID> (JPA 특화 기능)
```

### JpaRepository 주요 메서드

#### 기본 CRUD 메서드 (CrudRepository에서 상속)
- **`save(S entity)`**: 새로운 엔티티는 저장(persist), 기존 엔티티는 수정(merge)
- **`findOne(ID id)`**: 엔티티 하나 조회 (Spring Data JPA 2.x부터 `findById`로 변경)
- **`exists(ID id)`**: 엔티티 존재 여부 확인
- **`count()`**: 총 엔티티 개수 반환
- **`delete(T entity)`**: 엔티티 삭제
- **`findAll()`**: 모든 엔티티 조회

#### 페이징/정렬 메서드 (PagingAndSortingRepository에서 상속)
- **`findAll(Sort sort)`**: 정렬된 모든 엔티티 조회
- **`findAll(Pageable pageable)`**: 페이징 및 정렬된 엔티티 조회

#### JPA 특화 메서드
- **`findAll() : List<T>`**: 모든 엔티티를 List로 반환
- **`findAll(Sort sort) : List<T>`**: 정렬된 모든 엔티티를 List로 반환
- **`findAll(Iterable<ID> ids) : List<T>`**: 주어진 ID 목록에 해당하는 엔티티 조회
- **`save(Iterable<S> entities) : List<S>`**: 여러 엔티티를 일괄 저장
- **`flush()`**: 영속성 컨텍스트의 변경 내용을 DB에 즉시 반영
- **`saveAndFlush(T entity) : T`**: 저장 후 즉시 flush
- **`deleteInBatch(Iterable<T> entities)`**: 여러 엔티티를 일괄 삭제
- **`deleteAllInBatch()`**: 모든 엔티티를 일괄 삭제
- **`getOne(ID id) : T`**: 프록시 객체 반환 (Spring Data JPA 2.x부터 `getById` 또는 `getReferenceById`로 변경)

<br>
<br>

# 12.4 쿼리 메소드 기능

- 메서드 이름으로 쿼리 생성
- 메서드 이름으로 JPA NamedQuery 호출
- @Query 어노테이션을 활용해서 리포지토리 인터페잇에 쿼리 직접 정의

## 12.4.1 메서드 이름으로 쿼리 생성

- 메서드 이름만으로 쿼리를 자동 생성
- 규칙: `findBy` + `필드명` + `조건`

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    // SELECT m FROM Member m WHERE m.username = ?1
    Member findByUsername(String username);
    
    // SELECT m FROM Member m WHERE m.age > ?1
    List<Member> findByAgeGreaterThan(int age);
    
    // SELECT m FROM Member m WHERE m.username = ?1 AND m.age = ?2
    Member findByUsernameAndAge(String username, int age);
}
```

- 자세한 규칙은 책 546p 확인

<br>

## 12.4.2 JPA NamedQuery

### JPA NamedQuery 직접 호출
```java
public class MemberRepository {
    public List<Member> findByUsername(String username) {
        List<Member> resultList = 
            em.createNamedQuery("Member.findByUsername", Member.class)
              .setParameter("username", "회원1")
              .getResultList();
        return resultList;
    }
}
```

### Spring Data JPA NamedQuery 호출
Spring Data JPA를 사용하면 메서드 이름만으로 NamedQuery를 호출할 수 있다.

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    List<Member> findByUsername(@Param("username") String username);
}
```

- `도메인클래스.메소드이름`으로 NamedQuery를 찾아서 실행
  - 위의 예제에선 `Member.findByUsername` 라는 NamedQuery 실행
- NamedQuery가 없으면 메소드 이름으로 쿼리 생성 전략 사용

<br>

## 12.4.3 @Query, 리포지토리 메소드에 쿼리 정의

- `org.springframework.data.jpa.repository.Query` 어노테이션을 사용하여 리포지토리 메소드에 직접 쿼리를 정의
- 이 방식은 메소드에 정적 쿼리를 직접 작성하므로 '이름 없는 NamedQuery'라고도 불림
  - NamedQuery처럼 애플리케이션 실행 시점에 문법 오류를 발견할 수 있는 장점

### JPQL 쿼리 작성
```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    @Query("select m from Member m where m.username = ?1")
    Member findByUsername(String username);
}
```

### 네이티브 SQL 사용
- 네이티브 SQL을 사용하려면 `@Query` 어노테이션에 `nativeQuery = true`를 설정해야 함
- 파라미터 인덱스 주의사항:
  - JPQL: 위치 기반 파라미터가 1부터 시작 (`?1`, `?2`, ...)
  - 네이티브 SQL: 위치 기반 파라미터가 0부터 시작 (`?0`, `?1`, ...)

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    @Query(value = "SELECT * FROM MEMBER WHERE USERNAME = ?0",
           nativeQuery = true)
    Member findByUsername(String username);
}
```

<br>

## 12.4.4 파라미터 바인딩

Spring Data JPA는 위치 기반 파라미터 바인딩(default)과 이름 기반 파라미터 바인딩을 모두 지원한다.

```java
// 위치 기반 파라미터 바인딩(default)
select m from Member m where m.username = ?1

// 이름 기반 파라미터 바인딩
select m from Member m where m.username = :name
```

<br>

## 12.4.5 벌크성 수정 쿼리

Spring Data JPA에서 벌크성 수정 쿼리를 사용하려면 `@Modifying` 어노테이션을 사용해야 한다.

- 벌크성 수정 쿼리: 여러 개의 엔티티를 한 번에 수정하거나 삭제하는 쿼리

### @Modifying 어노테이션 사용
```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    @Modifying
    @Query("update Member m set m.age = m.age + 1 where m.age >= :age")
    int bulkAgePlus(@Param("age") int age);
}
```

- `@Modifying` 어노테이션이 있어야 `executeUpdate()`가 호출됨
- 벌크성 쿼리는 영속성 컨텍스트를 거치지 않고 바로 DB에 적용되기 때문에, 벌크성 쿼리 실행 후 영속성 컨텍스트를 초기화하는 것을 권장 (`@Modifying(clearAutomatically = true)` 또는 `em.clear()`)
- 메서드의 반환 타입은 영향받은 행(row)의 수를 나타내는 int로 설정하는 것이 일반적

### 벌크성 쿼리 실행 예제
```java
@Service
@Transactional
public class MemberService {
    
    @Autowired
    private MemberRepository memberRepository;
    
    public void bulkAgePlus(int age) {
        // 벌크성 수정 쿼리 실행
        int resultCount = memberRepository.bulkAgePlus(age);
        
        // 영속성 컨텍스트 초기화 (필요시)
        // em.clear();
        
        System.out.println("수정된 회원 수: " + resultCount);
    }
}
```

<br>

## 12.4.6 반환 타입

Spring Data JPA는 쿼리 메소드에 대해 아래와 같은 유연한 반환 타입을 지원한다.

### 컬렉션 인터페이스
- 결과가 한 건 이상일 것으로 예상될 때 사용
- 예시: `List<Member> findByName(String name);`
- 조회 결과가 없을 경우 **빈 컬렉션**을 반환

### 단건 엔티티
- 결과가 단 한 건일 것으로 예상될 때 사용
- 예시: `Member findByEmail(String email);`
- 조회 결과가 없을 경우 **`null`**을 반환

### 예외 처리
- 단건을 기대하고 반환 타입을 지정했는데 결과가 2건 이상 조회되면 `javax.persistence.NonUniqueResultException` 예외 발생
- Spring Data JPA는 단건으로 지정된 메서드를 호출할 때 내부적으로 JPQL의 `Query.getSingleResult()` 메서드를 호출
- `getSingleResult()` 호출 시 조회 결과가 없으면 `javax.persistence.NoResultException` 예외가 발생하지만, Spring Data JPA는 이 예외를 무시하고 대신 **`null`**을 반환

<br>

## 12.4.7 페이징과 정렬

Spring Data JPA는 쿼리 메소드에 페이징과 정렬 기능을 사용할 수 있도록 두 가지 특별한 파라미터를 제공한다.

- **`org.springframework.data.domain.Sort`**: 정렬 기능을 위한 파라미터
- **`org.springframework.data.domain.Pageable`**: 페이징 기능을 위한 파라미터 (내부적으로 `Sort` 기능을 포함)

### Page 반환 타입 사용
`Page`를 반환 타입으로 사용하면 Spring Data JPA가 자동으로 추가 `count` 쿼리를 실행하여 전체 레코드 수를 가져옵니다.

```java
// count 쿼리 사용
Page<Member> findByName(String name, Pageable pageable);

// count 쿼리 사용 안 함
List<Member> findByName(String name, Pageable pageable);
List<Member> findByName(String name, Sort sort);
```

### 페이징과 정렬 사용 예제

**검색 조건**: 이름이 "김"으로 시작하는 회원  
**정렬 조건**: 이름으로 내림차순  
**페이징 조건**: 첫 번째 페이지, 페이지당 보여줄 데이터는 10건

```java
// Repository 정의
public interface MemberRepository extends Repository<Member, Long> {
    Page<Member> findByNameStartingWith(String name, Pageable pageable);
}

// 사용 예제
// 페이징 조건과 정렬 조건 설정
PageRequest pageRequest = new PageRequest(0, 10, new Sort(Direction.DESC, "name"));

// 쿼리 실행
Page<Member> result = memberRepository.findByNameStartingWith("김", pageRequest);

// 결과 조회
List<Member> members = result.getContent();        // 조회된 데이터
int totalPages = result.getTotalPages();           // 전체 페이지 수
boolean hasNextPage = result.hasNextPage();        // 다음 페이지 존재 여부
```

### Page 인터페이스 주요 메서드
```java
public interface Page<T> extends Iterable<T> {
    int getNumber();                    // 현재 페이지
    int getSize();                      // 페이지 크기
    int getTotalPages();                // 전체 페이지 수
    int getNumberOfElements();          // 현재 페이지에 나올 데이터 수
    long getTotalElements();            // 전체 데이터 수
    boolean hasPreviousPage();          // 이전 페이지 여부
    boolean isFirstPage();              // 현재 페이지가 첫 페이지 인지 여부
    boolean hasNextPage();              // 다음 페이지 여부
    boolean isLastPage();               // 현재 페이지가 마지막 페이지 인지 여부
    Pageable nextPageable();            // 다음 페이지 객체, 다음 페이지가 없으면 null
    Pageable previousPageable();        // 이전 페이지 객체, 이전 페이지가 없으면 null
    List<T> getContent();               // 조회된 데이터
    boolean hasContent();               // 조회된 데이터 존재 여부
    Sort getSort();                     // 정렬 정보
}
```

`Pageable`과 `Page`를 사용하면 지루하고 반복적인 페이징 처리를 손쉽게 개발할 수 있다. 

<br>

## 12.4.8 힌트

JPA 쿼리 힌트를 사용하려면 `org.springframework.data.jpa.repository.QueryHints` 어노테이션을 사용한다.

- JPA 쿼리 힌트: 쿼리 실행 시 JPA 구현체에게 성능 최적화나 동작 방식을 미세 조정하도록 지시하는 추가 정보

```java
@QueryHints(@QueryHint(name = "org.hibernate.readOnly", value = "true"))
Member findByUsername(String username);
```

- 이 힌트는 조회된 엔티티에 대해 변경 감지를 생략시켜 JPA의 성능을 향상시키는 역할

<br>

## 12.4.9 락 (16.1절에서 자세히)

```java
@Lock(LockModeType.PESSIMISTIC_WRITE) // 비관적 락
List<Member> findByName(String name);
```

<br>
<br>

# 12.5 명세 (Specification)

- 명세(Specification)는 도메인 주도 설계(DDD)의 개념으로, Spring Data JPA는 이를 JPA Criteria API를 활용해 지원함
- 핵심 개념: Predicate(술어) – 특정 조건에 대해 참 또는 거짓을 판단하는 기준식 
  - 여러 Predicate는 AND, OR 등의 논리 연산으로 조합 가능 
  - 예를 들어, `age > 20`, `status = 'ACTIVE'` 같은 조건들을 각각 predicate로 표현할 수 있음

Spring Data JPA에서는 이러한 Predicate를 `org.springframework.data.jpa.domain.Specification<T>` 인터페이스를 통해 정의하며, 이를 통해 유연하고 재사용 가능한 동적 쿼리 구성이 가능하다.

- 구조: **Composite 패턴**을 사용해서 구성되어 있음
  - [Composite 패턴 위키피디아](https://en.wikipedia.org/wiki/Composite_pattern)
  - 여러 `Specification`을 조합해서 다양한 검색 조건을 쉽게 만들 수 있음

- 사용 방법: Repository에서 `org.springframework.data.jpa.repository.JpaSpecificationExecutor` 인터페이스를 상속받아야 함

```java
public interface OrderRepository extends JpaRepository<Order, Long>,
    JpaSpecificationExecutor<Order> {
}
```

```java
public interface JpaSpecificationExecutor<T> {
    T findOne(Specification<T> spec);
    List<T> findAll(Specification<T> spec);
    Page<T> findAll(Specification<T> spec, Pageable pageable);
    List<T> findAll(Specification<T> spec, Sort sort);
    long count(Specification<T> spec);
}
```

- JpaSpecificationExecutor의 메소드들은 Specification을 파라미터로 받아서 검색 조건으로 사용

<br>

## 예제
- `OrderSpec.java` = 검색 조건 정의서. 명세 정의 코드
  - 복잡하고 선택적인 검색 조건을 깔끔하고 유연하게 조합하기 위해 Specification이 필요
  - 더 복잡한 조건을 위해서는 그냥 QueryDSL...
- `findOrders()` = 조건들을 꺼내 조립해서 검색에 실제로 쓰는 곳. 명세 사용 코드


### 명세 사용 코드

```java
// 회원 이름과 주문 상태를 기준으로 주문을 조회
import static org.springframework.data.jpa.domain.Specifications.*; // where()
import static jpabook.jpashop.domain.spec.OrderSpec.*;

public List<Order> findOrders(String name) {
    List<Order> result = orderRepository.findAll(
        where(memberName(name)).and(isOrderStatus())
    );
    return result;
}
```

- **Specifications**: 명세들을 조립할 수 있도록 도와주는 클래스
  - `where()`, `and()`, `or()`, `not()` 메소드 제공
  - `where(...)` → 전체 조건 블록을 시작
  - `memberName(name)` → 회원 이름이 name인 조건 
  - `isOrderStatus()` → 특정 주문 상태인 조건 
  - `and()` → 두 조건을 AND로 묶음
- `findAll()`: 회원 이름 명세(memberName)와 주문 상태 명세(isOrderStatus)를 and로 조합해서 검색 조건으로 사용
- 팁: `import static`을 적용하면 더 읽기 쉬운 코드가 됨.
  - `OrderSpec.memberName()`을 `memberName()`처럼, 
  - `Specifications.where()`도 `where()`처럼 짧게 쓸 수 있음

### 명세 정의 코드

```java
package jpabook.jpashop.domain;

import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils;
import javax.persistence.criteria.*;

public class OrderSpec {

  // 회원 이름으로 주문을 필터링하는 명세 정의
  public static Specification<Order> memberName(final String memberName) {
    return new Specification<Order>() {
      @Override
      public Predicate toPredicate(Root<Order> root, CriteriaQuery<?> query, CriteriaBuilder builder) {
        // 검색 조건이 비어있으면 null 반환 → 조건 생략
        if (StringUtils.isEmpty(memberName)) return null;

        // Order → Member 조인 (inner join)
        Join<Order, Member> m = root.join("member", JoinType.INNER);

        // 회원 이름이 일치하는 조건 생성 (where m.name = :memberName)
        return builder.equal(m.get("name"), memberName);
      }
    };
  }

  // 주문 상태가 ORDER인 조건을 정의하는 명세
  public static Specification<Order> isOrderStatus() {
    return new Specification<Order>() {
      @Override
      public Predicate toPredicate(Root<Order> root, CriteriaQuery<?> query, CriteriaBuilder builder) {
        // 주문 상태가 'ORDER'인 조건 생성 (where o.status = 'ORDER')
        return builder.equal(root.get("status"), OrderStatus.ORDER);
      }
    };
  }
}
```

<br>
<br>

# 12.6 사용자 정의 리포지토리 구현

Spring Data JPA를 사용하면 인터페이스만 정의하고 구현체는 만들지 않아도 되지만, 때로는 특정 메소드를 직접 구현해야 할 필요가 있다.

- 이 경우, 리포지토리를 직접 구현하면 공통 인터페이스가 제공하는 모든 기능까지 구현해야 하는 문제가 발생할 수 있다.

- Spring Data JPA는 이러한 문제를 우회하여 필요한 메소드만 구현할 수 있는 방법을 제공한다.

<br>

## 1. 사용자 정의 인터페이스

직접 구현할 메서드를 위한 사용자 정의 인터페이스를 먼저 작성해야 한다.

```java
public interface MemberRepositoryCustom {
    public List<Member> findMemberCustom();
}
```

<br>

## 2. 사용자 정의 구현 클래스

다음으로 사용자 정의 인터페이스를 구현한 클래스를 작성해야 한다.

- 주의) 클래스 이름을 지을 때 **리포지토리 인터페이스 이름 뒤에 `Impl`을 붙여야 함
  - 예: `MemberRepository` 인터페이스의 커스텀 구현체는 `MemberRepositoryImpl`이 되어야 함
- 이렇게 해야 Spring Data JPA가 해당 클래스를 사용자 정의 구현 클래스로 인식

```java
public class MemberRepositoryImpl implements MemberRepositoryCustom {
    @Override
    public List<Member> findMemberCustom() {
        //사용자 정의 구현
        // ... 
    }
}
```

> ## 리포지토리 구현 클래스 접미사 설정
> 사용자 정의 리포지토리 구현 클래스의 이름이 기본적으로 `Impl`로 끝나는데, 이를 다른 이름으로 변경하고 싶을 때 `repository-impl-postfix` 속성을 사용한다.
> ### XML 설정
> ```xml
> <repositories base-package="jpabook.jpashop.repository"
>     repository-impl-postfix="Impl" />
> ```
> ### JavaConfig 설정
> ```java
> @EnableJpaRepositories(basePackages = "jpabook.jpashop.repository",
>     repositoryImplementationPostfix = "Impl")
> ```

<br>

## 3. 사용자 정의 인터페이스 상속

```java
public interface MemberRepository extends JpaRepository<Member, Long>, MemberRepositoryCustom {
}
```

<br>
<br>

# 12.7 Web 확장 (Web Extensions)

Spring Data 프로젝트는 Spring MVC와 함께 사용할 수 있는 편리한 기능을 제공한다: 
- 식별자로 도메인 클래스 바인딩
- 페이징, 정렬

## 12.7.1 설정 (Configuration)

Spring Data의 웹 확장 기능을 활성화하기 위해 `org.springframework.data.web.config.SpringDataWebConfiguration`을 Spring Bean으로 등록해야 한다.

### XML 설정
```xml
<bean class="org.springframework.data.web.config.SpringDataWebConfiguration" />
```

### JavaConfig 설정
`org.springframework.data.web.config.EnableSpringDataWebSupport` 어노테이션을 사용하면 된다.

```java
@Configuration
@EnableWebMvc
@EnableSpringDataWebSupport
public class WebAppConfig {
}
```

이 설정이 완료되면 **도메인 클래스 컨버터**와 페이징 및 정렬을 위한 `HandlerMethodArgumentResolver`가 스프링 빈으로 등록된다.

**등록되는 빈들**:
- **도메인 클래스 컨버터**: `org.springframework.data.repository.support.DomainClassConverter`
- **페이징**: `PageableHandlerMethodArgumentResolver`
- **정렬**: `SortHandlerMethodArgumentResolver`

<br>

## 12.7.2 도메인 클래스 컨버터 기능

- 도메인 클래스 컨버터는 HTTP 파라미터로 넘어온 엔티티의 ID를 사용하여 해당 엔티티 객체를 찾아서 바인딩해준다. 

다음과 같은 예제를 살펴보자.
- 특정 회원을 수정하는 화면을 보여주기 위해 컨트롤러는 HTTP 요청으로 넘어온 회원의 ID를 사용해서 리포지토리를 통해 회원 엔티티를 조회해야 한다.
- URL: `/member/memberUpdateForm?id=1`

```java
@Controller
public class MemberController {
    
    @Autowired
    private MemberRepository memberRepository;
    
    @RequestMapping("member/memberUpdateForm")
    public String memberUpdateForm(@RequestParam("id") Long id, Model model) {
        Member member = memberRepository.findOne(id); // 회원을 찾는다.
        model.addAttribute("member", member);
        return "member/memberSaveForm";
    }
}
```

### 도메인 클래스 컨버터 적용하면?

```java
@Controller
public class MemberController {
    
    @RequestMapping("member/memberUpdateForm")
    public String memberUpdateForm(@RequestParam("id") Member member, Model model) {
        model.addAttribute("member", member);
        return "member/memberSaveForm";
    }
}
```

- `@RequestParam("id") Member member`
  - 도메인 클래스 컨버터가 HTTP 요청으로 넘어온 `id`를 받아서 자동으로 `Member` 엔티티 객체로 변환
  - 컨트롤러 로직이 더 간결해짐

### 주의 (Persistence Context와 OSIV)

- 도메인 클래스 컨버터로 넘어온 `Member` 엔티티를 직접 수정해도 **실제 DB에는 반영되지 않는다**
  - 이유: 이는 **영속성 컨텍스트의 동작 방식**과 관련이 있으며, Spring Data JPA 자체와는 직접적인 관련이 없다. 자세한 설명은 13장에서 다룬다.

- **OSIV를 사용하지 않으면**:
  - 조회된 엔티티는 **준영속 상태**
  - JPA의 **변경 감지 기능**이 동작하지 않음
  - DB에 반영하려면 명시적으로 `merge()` 메소드를 사용해야 함 (예: `memberRepository.save(member)`)

- **OSIV를 사용하면**:
  - 조회된 엔티티는 **영속 상태**
  - 하지만 OSIV의 특성상 컨트롤러나 뷰 계층에서는 **플러시하지 않는다**
  - DB에 반영하려면 **트랜잭션을 시작하는 서비스 계층의 메소드를 호출**해야 함
  - 해당 서비스 계층 메소드가 완료되면 **플러시와 트랜잭션 커밋**이 발생하여 DB에 반영됨

<br>

## 12.7.3 페이징과 정렬 기능

Spring Data는 페이징과 정렬 기능을 제공하고, `HandlerMethodArgumentResolver`를 제공해서 Spring MVC에서 편리하게 사용할 수 있다.

- **페이징 기능**: `PageableHandlerMethodArgumentResolver`
- **정렬 기능**: `SortHandlerMethodArgumentResolver`

```java
@RequestMapping(value = "/members", method = RequestMethod.GET)
public String list(Pageable pageable, Model model) {
    Page<Member> page = memberService.findMembers(pageable);
    model.addAttribute("members", page.getContent());
    return "members/memberList";
}
```

- 메소드가 `Pageable`을 파라미터로 받는다
  - `Pageable`은 인터페이스이고, 내부적으로 `org.springframework.data.domain.PageRequest` 객체가 요청 파라미터로부터 생성된다

- **요청 파라미터**:
  - **`page`**: 현재 페이지 (0부터 시작)
  - **`size`**: 한 페이지에 노출할 데이터 수
  - **`sort`**: 정렬 조건
    - 형식: `sort=속성,속성...(ASC | DESC)`
    - 정렬 방향을 바꾸려면 `sort` 파라미터를 하나 더 추가해야 함

- **예시 URL**: `/members?page=0&size=20&sort=name,desc&sort=address.city`
  - 첫 번째 페이지 (`page=0`)
  - 페이지당 20개 (`size=20`)
  - 이름 내림차순 정렬 (`sort=name,desc`)
  - 그 다음 주소의 도시로 오름차순 정렬 (`sort=address.city`)

- **참고**: 페이지 번호를 1부터 시작하게 하려면 `PageableHandlerMethodArgumentResolver`를 직접 스프링 빈으로 등록하고 `setOneIndexedParameters` 속성을 `true`로 설정해야 한다

### 접두사 (Prefix)

- 여러 개의 페이징 정보가 필요할 때는 Spring Framework의 `@Qualifier` 어노테이션을 사용해서 구분한다.

- **접두사 구분 형식**: `{접두사명}_`

```java
public String list(@Qualifier("member") Pageable memberPageable,
                   @Qualifier("order") Pageable orderPageable) {
    // ...
}
```

- **URL 예시**: `/members?member_page=0&order_page=1`

### 기본값 (Default Value)

- `Pageable`의 기본값은 `page=0`, `size=20`이다.

- **기본값 변경**: `@PageableDefault` 어노테이션을 사용해서 변경할 수 있다

```java
@RequestMapping(value = "/members", method = RequestMethod.GET)
public String list(@PageableDefault(size = 12, sort = "name", direction = Sort.Direction.DESC) Pageable pageable) {
    // ...
}
```

<br>
<br>

# 12.8 스프링 데이터 JPA가 사용하는 구현체

Spring Data JPA가 제공하는 공통 인터페이스는 `org.springframework.data.jpa.repository.support.SimpleJpaRepository` 클래스가 구현한다.

## 12.8.1 SimpleJpaRepository

```java
@Repository
@Transactional(readOnly = true)
public class SimpleJpaRepository<T, ID extends Serializable> implements
    JpaRepository<T, ID>,
    JpaSpecificationExecutor<T> {

    @Transactional
    public <S extends T> S save(S entity) {
        if (entityInformation.isNew(entity)) {
            em.persist(entity);
            return entity;
        } else {
            return em.merge(entity);
        }
    }
}
```

**주요 특징**:
- `@Repository`: JPA 예외를 스프링이 추상화한 예외로 변환
- `@Transactional(readOnly = true)`: 기본적으로 읽기 전용
- `@Transactional`: 데이터 변경 메소드에 트랜잭션 적용

### @Repository 적용

> **JPA 예외를 스프링이 추상화한 예외로 변환한다**

### @Transactional 트랜잭션 적용

> **JPA의 모든 변경은 트랜잭션 안에서 이루어져야 한다**

- 스프링 데이터 JPA가 제공하는 공통 인터페이스를 사용하면 데이터를 변경(등록, 수정, 삭제)하는 메소드에 `@Transactional`로 트랜잭션 처리가 되어 있다
- 따라서 서비스 계층에서 트랜잭션을 시작하지 않으면 리포지토리에서 트랜잭션을 시작한다
- 물론 서비스 계층에서 트랜잭션을 시작했으면 리포지토리도 해당 트랜잭션을 전파받아서 그대로 사용한다

### @Transactional(readOnly = true)

> **데이터를 조회하는 메소드에는 `readOnly = true` 옵션이 적용되어 있다**

- 데이터를 변경하지 않는 트랜잭션에서 `readOnly = true` 옵션을 사용하면 **플러시를 생략해서** 약간의 성능 향상을 얻을 수 있다 (중요!)
- 자세한 내용은 15.4.2절에서 설명한다

### save() 메소드 동작 방식

> **이 메소드는 저장할 엔티티가 새로운 엔티티면 저장(persist)하고 이미 있는 엔티티면 병합(merge)한다**

- **새로운 엔티티를 판단하는 기본 전략**: 엔티티의 식별자로 판단
  - 식별자가 객체일 때 `null`
  - 자바 기본 타입일 때 숫자 `0` 값이면 새로운 엔티티로 판단
- 필요시 엔티티에 예제 12.32의 `Persistable` 인터페이스를 구현해서 판단 로직을 변경할 수 있다

```java
// Persistable 인터페이스
package org.springframework.data.domain;

public interface Persistable<ID extends Serializable> extends Serializable {
    ID getId();
    boolean isNew();
}
```

- **사용 목적**: Spring Data JPA가 엔티티의 신규 여부를 판단하는 로직을 개발자가 직접 정의할 수 있도록 제공
- **동작 방식**: `save()` 메소드는 이 `isNew()` 메소드의 반환 값을 기준으로 `persist` 또는 `merge`를 결정한다

<br>
<br>

# 12.9 JPA 샵에 적용

이번에는 앞서 만든 웹 애플리케이션에 스프링 데이터 JPA를 적용해보자. 단계별로 따라해보면 스프링 데이터 JPA가 얼마나 유용한지 알 수 있을 것이다.

**예제 코드**: `ch10-jpa-shop`

1. 환경설정
2. 리포지토리 리팩토링
3. 명세(Specification) 적용
4. 기타

## 12.9.1 환경설정

### 스프링 데이터 JPA 라이브러리 추가

### 예제 12.33 스프링 데이터 JPA 라이브러리

[`pom.xml`](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fpom.xml)에 `spring-data-jpa` 라이브러리를 추가한다.

```xml
<!-- 스프링 데이터 JPA -->
<dependency>
  <groupId>org.springframework.data</groupId>
  <artifactId>spring-data-jpa</artifactId>
    <version>3.1.5</version>
</dependency>
```

### 설정 방법

### 예제 12.34 Java 기반 설정 (현재 프로젝트 적용)

[`JpaConfig.java`](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fsrc%2Fmain%2Fjava%2Fjpabook%2Fjpashop%2Fconfig%2FJpaConfig.java)에 `@EnableJpaRepositories`를 추가한다. `basePackages` 속성에는 리포지토리가 위치한 패키지를 지정한다.

```java
package jpabook.jpashop.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@Configuration
@EnableJpaRepositories(basePackages = "jpabook.jpashop.repository") // Spring Data JPA Repository 스캔 활성화
public class JpaConfig {
}
```

### 예제 12.35 XML 기반 설정 (참고용)

[`webAppConfig.xml`](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fsrc%2Fmain%2Fresources%2FwebAppConfig.xml)에 `<context:component-scan>`을 추가하여 Java 설정을 스캔하도록 설정한다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd">

    <!-- Java 설정 클래스 스캔 -->
    <context:component-scan base-package="jpabook.jpashop.config"/>

</beans>
```

> **현재 프로젝트 설정**: `ch10-jpa-shop` 프로젝트는 **Java 기반 설정**을 사용한다. 

이제 스프링 데이터 JPA를 사용할 준비가 완료되었다.

<br>

## 12.9.2 리포지토리 리팩토링

### 회원 리포지토리 리팩토링

### 예제 12.35 회원 리포지토리 리팩토링 전

기존의 `MemberRepository` 클래스는 `EntityManager`를 직접 사용하여 CRUD 작업을 수행했다.

```java
@Repository
public class MemberRepository {

    @PersistenceContext
    EntityManager em;

    public void save(Member member) {
        em.persist(member);
    }

    public Member findOne(Long id) {
        return em.find(Member.class, id);
    }

    public List<Member> findAll() {
        return em.createQuery("select m from Member m", Member.class)
                .getResultList();
    }

    public List<Member> findByName(String name) {
        return em.createQuery("select m from Member m where m.name = :name", Member.class)
                .setParameter("name", name)
                .getResultList();
    }
}
```

### 예제 12.36 회원 리포지토리 리팩토링 후

[`MemberRepository.java`](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fsrc%2Fmain%2Fjava%2Fjpabook%2Fjpashop%2Frepository%2FMemberRepository.java)를 리팩토링한 후 코드를 보자.

클래스를 인터페이스로 변경하고 스프링 데이터 JPA가 제공하는 `JpaRepository`를 상속받았다. 제네릭 타입 `<Member, Long>`은 리포지토리가 관리할 엔티티 타입(`Member`)과 엔티티의 식별자 타입(`Long`)을 정의한다.

`save()`, `findById()`, `findAll()` 같은 기본 메소드들은 `JpaRepository`가 이미 제공하므로 제거했다. `findByName()`, `findByNameContaining()` 같은 나머지 메소드는 스프링 데이터 JPA가 메소드 이름을 분석해서 적절한 쿼리를 자동으로 실행한다.

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    List<Member> findByName(String name);
    List<Member> findByNameContaining(String name);
}
```

다음으로 상품 리포지토리를 리팩토링해보자.

### 상품 리포지토리 리팩토링

### 예제 12.37 상품 리포지토리 리팩토링 전

기존의 `ItemRepository` 클래스는 `EntityManager`를 직접 사용하여 CRUD 작업을 수행했다.

### 예제 12.38 상품 리포지토리 리팩토링 후

[`ItemRepository.java`](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fsrc%2Fmain%2Fjava%2Fjpabook%2Fjpashop%2Frepository%2FItemRepository.java)를 리팩토링한 후 모든 기능이 스프링 데이터 JPA가 제공하는 공통 인터페이스로 충분히 제공되므로 별도 메소드가 필요 없다.

```java
public interface ItemRepository extends JpaRepository<Item, Long> {
    List<Item> findByNameContaining(String name);
}
```

이제 주문 리포지토리를 리팩토링해보자.

### 주문 리포지토리 리팩토링

### 예제 12.39 주문 리포지토리 리팩토링 전

예제 12.39는 주문 리포지토리의 원본 코드다.

```java
@Repository
public class OrderRepository {

    @PersistenceContext
    EntityManager em;

    public void save(Order order) {
        em.persist(order);
    }

    public Order fineOne(Long id) {
        return em.find(Order.class, id);
    }

    public List<Order> findAll(OrderSearch orderSearch) {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<Order> cq = cb.createQuery(Order.class);
        Root<Order> o = cq.from(Order.class);
        // ... (나머지 findAll 메소드 구현은 생략됨)
    }
}
```

### 예제 12.40 주문 리포지토리 리팩토링 후

예제 12.39의 주문 리포지토리에는 검색이라는 복잡한 로직이 있다. 스프링 데이터 JPA가 제공하는 명세 기능을 사용해서 검색을 구현해보자. 명세 기능을 사용하기 위해 예제 12.40의 주문 리포지토리를 리팩토링한 후 코드에는 `JpaSpecificationExecutor`를 추가로 상속받았다.

```java
package jpabook.jpashop.repository;

import jpabook.jpashop.domain.Order;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

public interface OrderRepository extends JpaRepository<Order, Long>, JpaSpecificationExecutor<Order> {
}
```

## 12.9.3 명세 적용

### OrderSpec 클래스

[`OrderSpec.java`](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fsrc%2Fmain%2Fjava%2Fjpabook%2Fjpashop%2Fdomain%2FOrderSpec.java)는 JPA Criteria API를 사용하여 동적 검색 조건을 정의한다:

```java
package jpabook.jpashop.domain;

import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils;
import javax.persistence.criteria.*;

public class OrderSpec {

    // 회원 이름으로 주문을 필터링하는 명세 정의 (LIKE 검색)
    public static Specification<Order> memberNameLike(final String memberName) {
        return new Specification<Order>() {
            @Override
            public Predicate toPredicate(Root<Order> root, CriteriaQuery<?> query, CriteriaBuilder builder) {
                // 검색 조건이 비어있으면 null 반환 → 조건 생략
                if (StringUtils.isEmpty(memberName)) return null;

                // Order → Member 조인 (inner join)
                Join<Order, Member> m = root.join("member", JoinType.INNER);

                // 회원 이름이 포함되는 조건 생성 (where m.name LIKE '%memberName%')
                return builder.like(m.<String>get("name"), "%" + memberName + "%");
            }
        };
    }

    // 주문 상태가 특정 상태인 조건을 정의하는 명세
    public static Specification<Order> orderStatusEq(final OrderStatus orderStatus) {
        return new Specification<Order>() {
            @Override
            public Predicate toPredicate(Root<Order> root, CriteriaQuery<?> query, CriteriaBuilder builder) {
                if (orderStatus == null) return null;
                
                // 주문 상태가 일치하는 조건 생성 (where o.status = :orderStatus)
                return builder.equal(root.get("status"), orderStatus);
            }
        };
    }
}
```

**주요 특징**:
- **익명 클래스**: `new Specification<Order>()`를 사용하여 `toPredicate` 메소드 구현
- **동적 조건**: 검색 조건이 `null`이거나 비어있으면 `null` 반환하여 조건 생략
- **조인 처리**: `root.join("member", JoinType.INNER)`로 Order와 Member 테이블 조인
- **LIKE 검색**: `builder.like()`를 사용하여 회원 이름 부분 일치 검색 지원
- **재사용성**: 정적 메소드로 정의하여 여러 곳에서 재사용 가능

### OrderService 수정

[`OrderService.java`](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fsrc%2Fmain%2Fjava%2Fjpabook%2Fjpashop%2Fservice%2FOrderService.java)의 `findOrders` 메소드를 다음과 같이 수정했다:

```java
/** 주문 검색 */
public List<Order> findOrders(OrderSearch orderSearch) {
    // 책 내용과 동일하게 구현
    return orderRepository.findAll(orderSearch.toSpecification());
}
```

**주요 특징**:
- `OrderSearch.toSpecification()`을 호출하여 동적 검색 조건 생성
- `orderRepository.findAll(spec)`으로 Specification 기반 검색 실행

### OrderSearch 클래스

[`OrderSearch.java`](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fsrc%2Fmain%2Fjava%2Fjpabook%2Fjpashop%2Fdomain%2FOrderSearch.java)는 검색 조건과 동적 쿼리 생성을 위한 `toSpecification()` 메소드를 포함한다:

```java
package jpabook.jpashop.domain;

import org.springframework.data.jpa.domain.Specification;
import static jpabook.jpashop.domain.OrderSpec.memberNameLike;
import static jpabook.jpashop.domain.OrderSpec.orderStatusEq;

public class OrderSearch {

    private String memberName;      //회원 이름
    private OrderStatus orderStatus;//주문 상태

    //Getter, Setter
    public String getMemberName() {
        return memberName;
    }

    public void setMemberName(String memberName) {
        this.memberName = memberName;
    }

    public OrderStatus getOrderStatus() {
        return orderStatus;
    }

    public void setOrderStatus(OrderStatus orderStatus) {
        this.orderStatus = orderStatus;
    }

    // 검색 조건으로 Specification을 생성하는 메소드
    public Specification<Order> toSpecification() {
        Specification<Order> spec = null;
        
        if (memberName != null && !memberName.isEmpty()) {
            spec = memberNameLike(memberName);
        }
        
        if (orderStatus != null) {
            if (spec == null) {
                spec = orderStatusEq(orderStatus);
            } else {
                spec = spec.and(orderStatusEq(orderStatus));
            }
        }
        
        return spec;
    }
}
```

**주요 기능**:
- `toSpecification()`: 검색 조건을 기반으로 동적 `Specification` 생성
- `memberName` 조건이 설정된 경우 `OrderSpec.memberNameLike()` 호출 (LIKE 검색)
- `orderStatus` 조건이 설정된 경우 `OrderSpec.orderStatusEq()` 호출 (정확한 일치)
- 두 조건이 모두 설정된 경우 `and()`로 조합
- 조건이 없는 경우 `null` 반환하여 모든 주문 조회

## 12.9.4 기타

### 테스트 설정

- [`TestConfig.java`](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fsrc%2Ftest%2Fjava%2Fjpabook%2Fjpashop%2Fconfig%2FTestConfig.java)

### 테스트 실행

#### Spring Data JPA 테스트
[`SpringDataJpaTest.java`](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fsrc%2Ftest%2Fjava%2Fjpabook%2Fjpashop%2Frepository%2FSpringDataJpaTest.java)를 통해 Spring Data JPA 기능을 테스트할 수 있다:

```bash
mvn test -Dtest=SpringDataJpaTest
```

#### OrderSpec 단위 테스트
[`OrderSpecTest.java`](..%2FCH10-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EC%96%B8%EC%96%B4%2Fch10-jpa-shop%2Fsrc%2Fmain%2Fjava%2Fjpabook%2Fjpashop%2FOrderSpecTest.java)를 통해 OrderSpec의 동작을 직접 확인할 수 있다:

```bash
# 컴파일 후 실행
mvn compile
java -cp target/classes jpabook.jpashop.OrderSpecTest
```

<br>

# 12.10 스프링 데이터 JPA와 QueryDSL 통합

기존 리포지토리 코드를 스프링 데이터 JPA로 리팩토링한 후, 추가로 QueryDSL을 사용해보자. 스프링 데이터 JPA는 QueryDSL을 두 가지 방법으로 지원한다.

- `org.springframework.data.querydsl.QueryDslPredicateExecutor`
- `org.springframework.data.querydsl.QueryDslRepositorySupport`

## 12.10.1 QueryDslPredicateExecutor 사용

첫 번째 방법은 리포지토리에서 `QueryDslPredicateExecutor`를 상속받는 것이다.

```java
public interface ItemRepository
extends JpaRepository<Item, Long>, QueryDslPredicateExecutor<Item> {
}
```

이제 `ItemRepository`에서 QueryDSL을 사용할 수 있다.

### 예제 12.45 QueryDSL 사용 예제

예제 12.45는 QueryDSL이 생성한 쿼리 타입으로 장난감이라는 이름을 포함하고 있으면서 가격이 10000~20000원인 상품을 검색한다.

```java
QItem item = QItem.item;
Iterable<Item> result = itemRepository.findAll(
    item.name.contains("장난감").and(item.price.between(10000, 20000))
);
```

예제 12.46의 QueryDslPredicateExecutor 인터페이스를 보면 QueryDSL을 검색조건으로 사용하면서 스프링 데이터 JPA가 제공하는 페이징과 정렬 기능도 함께 사용할 수 있다.

### 예제 12.46 QueryDslPredicateExecutor 인터페이스

```java
public interface QueryDslPredicateExecutor<T> {
    T findOne(Predicate predicate);
    Iterable<T> findAll(Predicate predicate);
    Iterable<T> findAll(Predicate predicate, OrderSpecifier<?>... orders);
    Page<T> findAll(Predicate predicate, Pageable pageable);
    long count(Predicate predicate);
}
```

`QueryDslPredicateExecutor`는 스프링 데이터 JPA와 함께 QueryDSL을 사용하기 편리하지만 제약이 있다. `join`이나 `fetch`를 사용할 수 없다(JPQL에서 설명한 묵시적 조인은 가능하다). QueryDSL의 모든 기능을 사용하려면 `JPAQuery` 객체를 직접 사용하거나 스프링 데이터 JPA가 제공하는 `QueryDslRepositorySupport`를 상속받아서 사용해야 한다.

## 12.10.2 QueryDslRepositorySupport 사용

모든 QueryDSL 기능을 사용하려면 `JPAQuery` 객체를 직접 생성해서 사용해야 한다. 이때 `QueryDslRepositorySupport`를 상속받아서 사용하면 QueryDSL을 더 편리하게 사용할 수 있다.

### 예제 12.47 CustomOrderRepository 사용자 정의 리포지토리

```java
package jpabook.jpashop.repository.custom;

import jpabook.jpashop.domain.Order;
import jpabook.jpashop.domain.OrderSearch;
import java.util.List;

public interface CustomOrderRepository {
    public List<Order> search(OrderSearch orderSearch);
}
```

### 예제 12.48 QueryDslRepositorySupport 사용 코드

예제 12.48은 웹 애플리케이션 만들기에서 사용했던 주문 내역 검색 기능을 QueryDslRepositorySupport를 사용해서 QueryDSL로 구현한 예제다. 검색 조건에 따라 동적으로 쿼리를 생성한다. 참고로 생성자에서 QueryDslRepositorySupport에 엔티티 클래스 정보를 넘겨주어야 한다.

```java
package jpabook.jpashop.repository.custom;

import com.mysema.query.jpa.JPQLQuery;
import jpabook.jpashop.domain.Order;
import jpabook.jpashop.domain.OrderSearch;
import jpabook.jpashop.domain.QMember;
import jpabook.jpashop.domain.QOrder;
import org.springframework.data.jpa.repository.support.QueryDslRepositorySupport;
import org.springframework.util.StringUtils;
import java.util.List;

public class OrderRepositoryImpl extends QueryDslRepositorySupport
implements CustomOrderRepository {

    public OrderRepositoryImpl() {
        super(Order.class);
    }

    @Override
    public List<Order> search(OrderSearch orderSearch) {
        QOrder order = QOrder.order;
        QMember member = QMember.member;

        JPQLQuery query = from(order);

        if (StringUtils.hasText(orderSearch.getMemberName())) {
            query.leftJoin(order.member, member)
                 .where(member.name.contains(orderSearch.getMemberName()));
        }

        if (orderSearch.getOrderStatus() != null) {
            query.where(order.status.eq(orderSearch.getOrderStatus()));
        }

        return query.list(order);
    }
}
```

예제 12.49는 QueryDslRepositorySupport의 핵심 기능만 간추려보았다.

### 예제 12.49 QueryDslRepositorySupport 코드

```java
package org.springframework.data.jpa.repository.support;

@Repository
public abstract class QueryDslRepositorySupport {

    //엔티티 매니저 반환
    protected EntityManager getEntityManager() {
        return entityManager;
    }

    //from 절 반환 
    protected JPQLQuery from(EntityPath<?>... paths) {
        return querydsl.createQuery(paths);
    }

    //QueryDSL delete 절 반환
    protected DeleteClause<JPADeleteClause> delete(EntityPath<?> path) {
        return new JPADeleteClause(entityManager, path);
    }

    //QueryDSL update 절 반환 
    protected UpdateClause<JPAUpdateClause> update(EntityPath<?> path) {
        return new JPAUpdateClause(entityManager, path);
    }

    //스프링 데이터 JPA가 제공하는 Querydsl을 편하게 사용하도록 돕는 
    //핼퍼 객체 반환
    protected Querydsl getQuerydsl() {
        return this.querydsl;
    }
}
```

<br>

# 12.11 정리

지금까지 스프링 데이터 JPA 기능을 학습하고 앞서 만든 웹 애플리케이션에 적용해보았다. 적용한 예제를 보면 지루한 데이터 접근 계층의 코드가 상당히 많이 줄어든 것을 알 수 있다. 스프링 데이터 JPA는 버전이 올라가면서 다양한 기능이 추가되고 있다. 필자는 스프링 프레임워크와 JPA를 함께 사용한다면 스프링 데이터 JPA는 선택이 아닌 필수라 생각한다고 한다. 다음 장에서는 J2EE와 스프링 컨테이너 환경에서 영속성 컨텍스트가 어떻게 동작하는지 알아보자.