JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원한다.(JPQL, Criteria, 네이티브 SQL)
그중 JPQL은 가장 중요한 객체지향 쿼리 언어이다.
Criteria나 QueryDSL도 결국 JPQL을 만들어주는 빌더 역할을 할 뿐이므로 JPA를 사용하는 개발자라면 PQL을 잘 알아야 한다.

# 10.1 객체지향 쿼리 소개

## 10.1.1 JPQL 소개

`find()`나 `get()`으로는 복잡합 검색 기능 구현 시 한계가 있으므로, JPQl을 사용하자. JPQL은 다음과 같은 특징을 갖는다.

- SQL이 데이터베이스 테이블을 대상으로 한다면, JPQL은 **엔티티 객체를 대상으로 검색**하는 방식이다 (ORM 기술을 사용하면 데이터베이스 테이블이 아닌 객체 대상으로 개발을 진행하므로 JPQL이 요구됨)
- SQL을 추상화해서 **특정 데이터베이스 SQL에 의존하지 않는다**
- 엔티티 직접 조회, 묵시적 조인, 다형성 지원으로 SQL보다 간결하다
  - ex. 회원이름이 kim인 엔터티 조회:
    - JPQL
  
    ```JAVA
    String jpql = "select m from Member as m where m.username = 'kim'";
    Listmember resultList = em.createQuery(jpql, Member.class).getResultList();
    ```
    
    - SQL
    
    ```SQL
    select
    member.id as id,
    member.age as age,
    member.team_id as team,
    member.name as name
    from
    Member member
    where
    member.name='kim'
    ```

<br>

## 10.1.2 Criteria 쿼리 소개 (거의 안 씀)

Criteria는 JPQL을 생성하는 빌더 클래스다. 

- 프로그래밍 코드로 JPQL을 작성하므로
- 컴파일 시점에 오류를 발견할 수 있다
- IDE을 사용한 코드 자동완성이 가능하다
- 동적 쿼리를 작성하기 편하다
- 코드가 길어지고 복잡해질 수 있다 (⇒ 대신 QueryDSL 사용)

위에서 살펴본 회원이름이 kim인 엔터티 조회 예제를 Criteria로 작성해보자.

```JAVA
//Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

//루트 클래스 (조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

//쿼리 생성: 코드로 작성
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "hello")); // 만약 필드명도 코드로 작성하고 싶으면 MetaModel API 사용
List<Member> resultList = em.createQuery(cq).getResultList();
```

다음으로, 동적 쿼리를 작성하기 편하단 부분에 대해 코드로 살펴보자. 사용자가 검색 조건으로 username과 age를 입력하는 경우의 예시이다.

- JPQL에서는 문자열을 직접 조립해야 해서 코드가 지저분해질 수 있다

```JAVA
String jpql = "select m from Member m where 1=1";
if (username != null) {
    jpql += " and m.username = :username";
}
if (age != null) {
    jpql += " and m.age = :age";
}
```

- Criteria API는 코드 안에서 객체로 쿼리를 만들기 때문에 훨씬 깔끔하게 처리할 수 있다

```JAVA
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);
Root<Member> m = query.from(Member.class);

List<Predicate> predicates = new ArrayList<>();
if (username != null) {
    predicates.add(cb.equal(m.get("username"), username));
}
if (age != null) {
    predicates.add(cb.equal(m.get("age"), age));
}

query.select(m).where(cb.and(predicates.toArray(new Predicate[0])));
List<Member> result = em.createQuery(query).getResultList();
```

<br>

## 10.1.3 QueryDSL 소개

QueryDSL도 Criteria처럼 JPQL 빌더이나, JPA 표준은 아니고 오픈소스 프레임워크이다. 
문자가 아닌 자바코드로 JPQL을 작성할 수 있으므로 위에 작성한 Criteria와 동일한 장점을 가지며, Criteria보다 단순하고 쉬워 실무에서 사용 권장된다.

```JAVA
// 사용 준비
JPAFactoryQuery query = new JPAQueryFactory(em);
QMember m = QMember.member;

// 쿼리
List<Member> list = query.selectFrom(m)
        .where(m.age.gt(18))
        .orderBy(m.name.desc())
        .fetch();
```

<br>

## 10.1.4 네이티브 SQL 소개

네이티브 SQL은 JPA가 제공하는 SQL을 직접 사용하는 기능이다. 표준화되어있지 않아 JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능이 필요할 때 사용한다. (오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트)

```JAVA
String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";
List<Member> resultList = em.createNativeQuery(sql, Member.class).getResultList();
```

JPQL과 굉장히 유사한데, `em.createQuery` 대신 `em.createNativeQuery`를 사용하면 된다.

<br>

## 10.1.5 JDBC 직접 사용

드물겠지만, JPA를 쓰면서도 가끔 JDBC 직접 사용하거나 JdbcTemplate나 마이바티스 등 다른 SQL 방식을 같이 쓰는 경우가 있다.
이때 문제는, JPA는 영속성 컨텍스트라는 1차 캐시를 갖고 있어서 DB와의 상태가 항상 일치하지 않을 수 있다는 점이다.

- JPA가 SQL을 날리기 전에 수동으로 `flush()` 해줘야함에 유의하자

<br>
<br>

# 10.2 JPQL

<br>
<br>

# 10.3 Criteria
