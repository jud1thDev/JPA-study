JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원한다.(JPQL, Criteria, 네이티브 SQL)
그중 JPQL은 가장 중요한 객체지향 쿼리 언어이다.
Criteria나 QueryDSL도 결국 JPQL을 만들어주는 빌더 역할을 할 뿐이므로 JPA를 사용하는 개발자라면 PQL을 잘 알아야 한다.

# 10.1 객체지향 쿼리 소개

## 10.1.1 JPQL 소개

`find()`나 `get()`으로는 복잡합 검색 기능 구현 시 한계가 있으므로, JPQl을 사용하자. JPQL은 다음과 같은 특징을 갖는다.

- SQL이 데이터베이스 테이블을 대상으로 한다면, JPQL은 **엔티티 객체를 대상으로 검색**하는 방식이다 (ORM 기술을 사용하면 데이터베이스 테이블이 아닌 객체 대상으로 개발을 진행하므로 JPQL이 요구됨)
- SQL을 추상화해서 **특정 데이터베이스 SQL에 의존하지 않는다**
- JPQL은 결국 SQL로 변환된다
- 엔티티 직접 조회, 묵시적 조인, 다형성 지원으로 SQL보다 간결하다
  - ex. 회원이름이 kim인 엔터티 조회:
    - JPQL
  
    ```JAVA
    String jpql = "select m from Member as m where m.username = 'kim'";
    Listmember resultList = em.createQuery(jpql, Member.class).getResultList();
    ```
    
    - SQL
    
    ```SQL
    select
    member.id as id,
    member.age as age,
    member.team_id as team,
    member.name as name
    from
    Member member
    where
    member.name='kim'
    ```

<br>

## 10.1.2 Criteria 쿼리 소개 (거의 안 씀)

Criteria는 JPQL을 생성하는 빌더 클래스다. 

- 프로그래밍 코드로 JPQL을 작성하므로
- 컴파일 시점에 오류를 발견할 수 있다
- IDE을 사용한 코드 자동완성이 가능하다
- 동적 쿼리를 작성하기 편하다
- 코드가 길어지고 복잡해질 수 있다 (⇒ 대신 QueryDSL 사용)

위에서 살펴본 회원이름이 kim인 엔터티 조회 예제를 Criteria로 작성해보자.

```JAVA
//Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

//루트 클래스 (조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

//쿼리 생성: 코드로 작성
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "hello")); // 만약 필드명도 코드로 작성하고 싶으면 MetaModel API 사용
List<Member> resultList = em.createQuery(cq).getResultList();
```

다음으로, 동적 쿼리를 작성하기 편하단 부분에 대해 코드로 살펴보자. 사용자가 검색 조건으로 username과 age를 입력하는 경우의 예시이다.

- JPQL에서는 문자열을 직접 조립해야 해서 코드가 지저분해질 수 있다

```JAVA
String jpql = "select m from Member m where 1=1";
if (username != null) {
    jpql += " and m.username = :username";
}
if (age != null) {
    jpql += " and m.age = :age";
}
```

- Criteria API는 코드 안에서 객체로 쿼리를 만들기 때문에 훨씬 깔끔하게 처리할 수 있다

```JAVA
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);
Root<Member> m = query.from(Member.class);

List<Predicate> predicates = new ArrayList<>();
if (username != null) {
    predicates.add(cb.equal(m.get("username"), username));
}
if (age != null) {
    predicates.add(cb.equal(m.get("age"), age));
}

query.select(m).where(cb.and(predicates.toArray(new Predicate[0])));
List<Member> result = em.createQuery(query).getResultList();
```

<br>

## 10.1.3 QueryDSL 소개

QueryDSL도 Criteria처럼 JPQL 빌더이나, JPA 표준은 아니고 오픈소스 프레임워크이다. 
문자가 아닌 자바코드로 JPQL을 작성할 수 있으므로 위에 작성한 Criteria와 동일한 장점을 가지며, Criteria보다 단순하고 쉬워 실무에서 사용 권장된다.

```JAVA
// 사용 준비
JPAFactoryQuery query = new JPAQueryFactory(em);
QMember m = QMember.member;

// 쿼리
List<Member> list = query.selectFrom(m)
        .where(m.age.gt(18))
        .orderBy(m.name.desc())
        .fetch();
```

<br>

## 10.1.4 네이티브 SQL 소개

네이티브 SQL은 JPA가 제공하는 SQL을 직접 사용하는 기능이다. 표준화되어있지 않아 JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능이 필요할 때 사용한다. (오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트)

```JAVA
String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";
List<Member> resultList = em.createNativeQuery(sql, Member.class).getResultList();
```

JPQL과 굉장히 유사한데, `em.createQuery` 대신 `em.createNativeQuery`를 사용하면 된다.

<br>

## 10.1.5 JDBC 직접 사용

드물겠지만, JPA를 쓰면서도 가끔 JDBC 직접 사용하거나 JdbcTemplate나 마이바티스 등 다른 SQL 방식을 같이 쓰는 경우가 있다.
이때 문제는, JPA는 영속성 컨텍스트라는 1차 캐시를 갖고 있어서 DB와의 상태가 항상 일치하지 않을 수 있다는 점이다.

- JPA가 SQL을 날리기 전에 수동으로 `flush()` 해줘야함에 유의하자

<br>
<br>

# 10.2 JPQL

## 10.2.1 기본 문법과 쿼리 API

```SQL
select_문 :: =
select_절
from_절
[where_절]
[groupby_절]
[having_절]
[orderby_절]

update_문 :: = update_절 [where_절]
delete_문 :: = delete_절 [where_절]
```

- JPQL도 SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용할 수 있다
- 엔티티를 저장할 때는 EntityManager.persist() 메소드를 사용하면 되므로 INSERT 문은 없다

### SELECT

```SQL
SELECT m FROM Member AS m where m.username = 'Hello'

SELECT m FROM Member m where m.username = 'Hello'
```

- 엔티티와 속성은 대소문자를 구분한다 (Member, username)
- SELECT, FROM, AS 같은 JPQL 키워드는 대소문자를 구분하지 않는다
- Member는 클래스명이 아니라 엔티티명이더 (`@Entity(name="XXX")`)
- 별칭이 필수이다 (AS는 생략 가능)

### TypeQuery, Query

- 작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다
- 쿼리 객체는 TypeQuery와 Query가 있다
  - TypeQuery 객체: 반환할 타입을 명확하게 지정할 수 있을 떄 사용
  - Query 객체: 반환 타입을 명확하게 지정할 수 없을 떄 사용

```JAVA
// TypeQuery 사용 : 반환타입이 Member로 명확함
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);

List<Member> resultList = query.getResultList();
for(Member member : resultList) {
    System.out.println("member = " + member);
}

// Query 사용: 반환 타입이 String username, Integer age로 명확하지 않음
Query query = em.createQuery("SELECT m.username, m.age from Member m");
List resultList = query.getResultList();

for(Object o : resultList) {
    Object[] result = (Object[]) o; // 결과가 둘 이상이면 Object[] 반환
}
```

두 코드를 비교해보면 타입을 변환할 필요가 없는 TypeQuery를 사용하는 것이 더 편리한 것을 알 수 있다.

- `getResultList()`, `getSingleResultList()`: 쿼리를 실행해서 데이터베이스 조회 결과를 반환
-  `getResultList()`: 결과가 하나 이상일 때 리스트를 반환하며, 결과가 없다면 빈 리스트를 반환
- `getSingleResultList()`: 단일 객체를 반환하며, 결과가 정확히 1개가 아니면 예외가 발생한다

<br>

## 10.2.2 파라미터 바인딩

- 파라미터 바인딩(Parameter Binding)은 쿼리 안에 값을 직접 넣지 않고, 외부에서 값을 주입해서 사용하는 방식이다
- 2가지 바인딩 방식이 있다 → :name 또는 ?1 같은 **기호로 변수화한 뒤, `setParameter()`로 값을 주입**한다.
  - 이름 기반(named parameter): :name, :age 이런 식으로 이름을 붙여줌 
  - 위치 기반(positional parameter): ?1, ?2 이런 식으로 순서에 따라 값을 넣음
- 이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확하다

```JAVA
// 이름 기반
SELECT m FROM Member m where m.username=:username
query.setParameter("username", usernameParam);
```

```JAVA
// 위치 기반
SELECT m FROM Member m where m.username=?1
query.setParameter(1, usernameParam);
```

<br>

## 10.2.3 프로젝션

- 프로젝션: SELECT절에 조회할 대상을 지정하는 것 
- 프로젝션 대상: 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자등 기본 데이터 타입)
  - 중복 제거 시 DISTINCT 사용

### 엔티티 프로젝션

```JAVA
// Member 조회
List<Member> result = em.createQuery("SELECT m FROM Member m", Member.class).getResultList();
```
- 결과는 영속성 컨텍스트에서 관리됨 (변경 감지 가능)

```JAVA
// Member과 연관된 team 조회
List<Team> result = em.createQuery("SELECT m.team FROM Member m", Team.class).getResultList();
```
- 위의 경우 조인이 내부적으로 일어나지만(inner join), 혼동 방지 위해 명시적 조인 권장됨 (SELECT t FROM Member m JOIN m.team t)

### 임베디드 타입 프로젝션

```JAVA
List<Address> addresses = em.createQuery("SELECT m.address FROM Member m", Address.class).getResultList();
```
- 임베디드 타입은 단독으로 존재하지 않고, 항상 엔티티에 포함되어야 함(m.address)
- 엔티티 타입이 아니라 값 타입이므로, 결과는 영속성 컨텍스트에서 관리되지 않음

### 스칼라 타입 프로젝션

- 스칼라 타입: 숫자, 문자, 날짜와 같은 기본 데이터 타입

```JAVA
List<String> usernames = em.createQuery("SELECT username FROM Member m", String.class).getResultList();
```

### 여러 값 조회

```JAVA
List<Object[]> result = em.createQuery("SELECT m.username, m.age FROM Member m").getResultList();
```

- 여러 필드를 그냥 배열로 담아서 가져오는 방식으로, 인덱스로 꺼내는 부분이나 형변환 하는 부분이 불편함

```JAVA
Object[] row = result.get(0);
String username = (String) row[0];
Integer age = (Integer) row[1];
```

### NEW 명령어 (DTO로 조회)

```JAVA
List<UserDTO> result = em.createQuery(
                "SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m",
                UserDTO.class
        ).getResultList();
```

- JPA가 쿼리 결과로 바로 DTO 객체를 만들어주는 방식으로, 코드가 깔끔함
- UserDTO 클래스에 생성자 필요
- 패키지 포함한 전체 경로 필요

<br>

## 10.2.4 페이징 API

JPA는 페이징을 다음 두 API로 추상화한다.

- setFirstResult(int startPosition) : 조회 시작 위치 (0부터 시작)
- setMaxResults(int maxResult) : 조회할 데이터 수

```JAVA
String jpql = "select m from Member m order by m.age desc";
List<Member> resultList = em.createQuery(jpql, Member.class)
        .setFirstResult(1)
        .setMaxResults(10)
        .getResultList();
```
age를 기준으로 내림차순 정렬하고 있으며, 2번째(0에서 시작이므로)부터 11번째까지(10개 가져옴)의 데이터를 가져온다는 의미이다.

- DB마다 페이징 처리 SQL 문법이 다르다.
  - MYSQL: LIMIT 사용
  - ORACLE: ROWNUM 사용

<br>

## 10.2.5 집합과 정렬

Aggression 함수(COUNT, AVG, MAX, MIN 등)와 GROUP BY, HAVING, ORDER BY 에 대한 얘기가 나오는데 아는 얘기라 스킵한다. 

<br>

## 10.2.6 JPQL 조인

- SQL 조인과 기능은 같고 문법이 약간 다르다

### 내부 조인

```JAVA
SELECT m FROM Member m INNER JOIN m.team t WHERE t.name = :teamName
```
- INNER 생략 가능
- SQL에서는 조인을 할 때 ON 절을 통해 외래키와 기본키의 일치 조건을 명시해야 하지만, JPQL에서는 연관 필드(m.team) 를 통해 자동으로 조인 조건을 처리함
  - SQL
  ```SQL
  SELECT m.* 
  FROM Member m
  INNER JOIN Team t ON m.team_id = t.id
  WHERE t.name = ?
  ```

### 외부 조인

```JAVA
SELECT m FROM Member m LEFT JOIN m.team t
```
- OUTER 생략 가능

### 컬렉션 조인

```JAVA
SELECT t, m FROM Team t LEFT JOIN t.members m
```
- t.members는 Team 엔티티가 가지고 있는 일대다(`@OneToMany`) 컬렉션 연관 필드
- JPQL에서는 일대다 관계(+ 일대다로 풀어써야하지만 다대다 관계)에서 컬렉션 값 연관 필드를 사용해서 조인을 간단하게 표현할 수 있다

### 세타 조인

```JAVA
SELECT m FROM Member m, Team t WHERE m.username = t.name
```
- **연관 없는 엔티티끼리 조인 가능** : 여기서는 m.username, t.name
- 내부 조인만 가능

### ON 절 (JPA 2.1+ 지원)

```JAVA
SELECT m, t FROM Member m LEFT JOIN m.team t ON t.name = 'A'
```
- ON절 사용 시 조인 대상을 필터링 하고 조인 가능: 여기서는 t.name = 'A'로 조인 시점에 조인 대상 필터링
- 내부 조인의 ON절은 WHERE절을 사용할 때와 결과 동일하므로, ON절은 보통 외부 조인에서만 사용

<br>

## 10.2.7 페치 조인

- 페치 조인이란, SQL에서 얘기하는 조인의 종류는 아니고 JPQL에서 성능 최적화를 위해 제공하는 기능
- 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능
- join fetch 명령어로 사용 가능

### 엔티티 페치 조인

```JAVA
SELECT m FROM Member m JOIN FETCH m.team
```
- 연관된 팀까지 한 번에 조회 (지연 로딩 무시됨)

### 컬렉션 페치 조인

```JAVA
SELECT t FROM Team t JOIN FETCH t.members WHERE t.name = '팀A'
```
- 결과가 중복될 수 있음 → DISTINCT로 해결

### 페치 조인과 DISTINCT

```JAVA
SELECT DISTINCT t FROM Team t JOIN FETCH t.members
```
- SQL + 애플리케이션 레벨 중복 제거

### 페치 조인과 일반 조인의 차이

- 일반 조인: 조인은 하지만, select 절에는 지정된 엔티티만 조회함 → 연관된 필드는 여전히 지연 로딩이 적용되어, 실제 접근 시 쿼리가 나감 / 즉시 로딩이라면, 로딩을 위해 쿼리가 한 번 더 나감
- 페치 조인: 조인을 하면서 연관된 엔티티까지 즉시 로딩함 → 즉, 쿼리 한 번으로 연관 엔티티도 메모리에 로딩됨

### 페치 조인의 특징 및 한계 

- 별칭 사용 불가 
- 컬렉션 두 개 이상 페치 불가 
- 컬렉션 페치 시 페이징 불가

<br>

## 10.2.8 경로 표현식

- 경로 표현식: .을 찍어 객체 그래프를 탐색하는 것
- 
<br>

## 10.2.9 서브 쿼리

<br>

## 10.2.10 조건식

<br>

## 10.2.11 다형성 쿼리

<br>

## 10.2.12 사용자 정의 함수 호출(JPA 2.1)

<br>

## 10.2.13 기타 정리

<br>

## 10.2.14 엔티티 직접 사용

<br>

## 10.2.15 Named 쿼리: 정적 쿼리

<br>
<br>

# 10.3 Criteria

- JPQL과 내용이 많이 중복되고, Criteria 사용은 권장되지 않으므로 생략한다.