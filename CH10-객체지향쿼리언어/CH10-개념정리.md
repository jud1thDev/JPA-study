JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원한다.(JPQL, Criteria, 네이티브 SQL)
그중 JPQL은 가장 중요한 객체지향 쿼리 언어이다.
Criteria나 QueryDSL도 결국 JPQL을 만들어주는 빌더 역할을 할 뿐이므로 JPA를 사용하는 개발자라면 PQL을 잘 알아야 한다.

# 10.1 객체지향 쿼리 소개

## 10.1.1 JPQL 소개

`find()`나 `get()`으로는 복잡합 검색 기능 구현 시 한계가 있으므로, JPQl을 사용하자. JPQL은 다음과 같은 특징을 갖는다.

- SQL이 데이터베이스 테이블을 대상으로 한다면, JPQL은 **엔티티 객체를 대상으로 검색**하는 방식이다 (ORM 기술을 사용하면 데이터베이스 테이블이 아닌 객체 대상으로 개발을 진행하므로 JPQL이 요구됨)
- SQL을 추상화해서 **특정 데이터베이스 SQL에 의존하지 않는다**
- JPQL은 결국 SQL로 변환된다
- 엔티티 직접 조회, 묵시적 조인, 다형성 지원으로 SQL보다 간결하다
  - ex. 회원이름이 kim인 엔터티 조회:
    - JPQL
  
    ```JAVA
    String jpql = "select m from Member as m where m.username = 'kim'";
    Listmember resultList = em.createQuery(jpql, Member.class).getResultList();
    ```
    
    - SQL
    
    ```SQL
    select
    member.id as id,
    member.age as age,
    member.team_id as team,
    member.name as name
    from
    Member member
    where
    member.name='kim'
    ```

<br>

## 10.1.2 Criteria 쿼리 소개 (거의 안 씀)

Criteria는 JPQL을 생성하는 빌더 클래스다. 

- 프로그래밍 코드로 JPQL을 작성하므로
- 컴파일 시점에 오류를 발견할 수 있다
- IDE을 사용한 코드 자동완성이 가능하다
- 동적 쿼리를 작성하기 편하다
- 코드가 길어지고 복잡해질 수 있다 (⇒ 대신 QueryDSL 사용)

위에서 살펴본 회원이름이 kim인 엔터티 조회 예제를 Criteria로 작성해보자.

```JAVA
//Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

//루트 클래스 (조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

//쿼리 생성: 코드로 작성
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "hello")); // 만약 필드명도 코드로 작성하고 싶으면 MetaModel API 사용
List<Member> resultList = em.createQuery(cq).getResultList();
```

다음으로, 동적 쿼리를 작성하기 편하단 부분에 대해 코드로 살펴보자. 사용자가 검색 조건으로 username과 age를 입력하는 경우의 예시이다.

- JPQL에서는 문자열을 직접 조립해야 해서 코드가 지저분해질 수 있다

```JAVA
String jpql = "select m from Member m where 1=1";
if (username != null) {
    jpql += " and m.username = :username";
}
if (age != null) {
    jpql += " and m.age = :age";
}
```

- Criteria API는 코드 안에서 객체로 쿼리를 만들기 때문에 훨씬 깔끔하게 처리할 수 있다

```JAVA
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);
Root<Member> m = query.from(Member.class);

List<Predicate> predicates = new ArrayList<>();
if (username != null) {
    predicates.add(cb.equal(m.get("username"), username));
}
if (age != null) {
    predicates.add(cb.equal(m.get("age"), age));
}

query.select(m).where(cb.and(predicates.toArray(new Predicate[0])));
List<Member> result = em.createQuery(query).getResultList();
```

<br>

## 10.1.3 QueryDSL 소개

QueryDSL도 Criteria처럼 JPQL 빌더이나, JPA 표준은 아니고 오픈소스 프레임워크이다. 
문자가 아닌 자바코드로 JPQL을 작성할 수 있으므로 위에 작성한 Criteria와 동일한 장점을 가지며, Criteria보다 단순하고 쉬워 실무에서 사용 권장된다.

```JAVA
// 사용 준비
JPAFactoryQuery query = new JPAQueryFactory(em);
QMember m = QMember.member;

// 쿼리
List<Member> list = query.selectFrom(m)
        .where(m.age.gt(18))
        .orderBy(m.name.desc())
        .fetch();
```

<br>

## 10.1.4 네이티브 SQL 소개

네이티브 SQL은 JPA가 제공하는 SQL을 직접 사용하는 기능이다. 표준화되어있지 않아 JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능이 필요할 때 사용한다. (오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트)

```JAVA
String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";
List<Member> resultList = em.createNativeQuery(sql, Member.class).getResultList();
```

JPQL과 굉장히 유사한데, `em.createQuery` 대신 `em.createNativeQuery`를 사용하면 된다.

<br>

## 10.1.5 JDBC 직접 사용

드물겠지만, JPA를 쓰면서도 가끔 JDBC 직접 사용하거나 JdbcTemplate나 마이바티스 등 다른 SQL 방식을 같이 쓰는 경우가 있다.
이때 문제는, JPA는 영속성 컨텍스트라는 1차 캐시를 갖고 있어서 DB와의 상태가 항상 일치하지 않을 수 있다는 점이다.

- JPA가 SQL을 날리기 전에 수동으로 `flush()` 해줘야함에 유의하자

<br>
<br>

# 10.2 JPQL

## 10.2.1 기본 문법과 쿼리 API

```SQL
select_문 :: =
select_절
from_절
[where_절]
[groupby_절]
[having_절]
[orderby_절]

update_문 :: = update_절 [where_절]
delete_문 :: = delete_절 [where_절]
```

- JPQL도 SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용할 수 있다
- 엔티티를 저장할 때는 EntityManager.persist() 메소드를 사용하면 되므로 INSERT 문은 없다

### SELECT

```SQL
SELECT m FROM Member AS m where m.username = 'Hello'

SELECT m FROM Member m where m.username = 'Hello'
```

- 엔티티와 속성은 대소문자를 구분한다 (Member, username)
- SELECT, FROM, AS 같은 JPQL 키워드는 대소문자를 구분하지 않는다
- Member는 클래스명이 아니라 엔티티명이더 (`@Entity(name="XXX")`)
- 별칭이 필수이다 (AS는 생략 가능)

### TypeQuery, Query

- 작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다
- 쿼리 객체는 TypeQuery와 Query가 있다
  - TypeQuery 객체: 반환할 타입을 명확하게 지정할 수 있을 떄 사용
  - Query 객체: 반환 타입을 명확하게 지정할 수 없을 떄 사용

```JAVA
// TypeQuery 사용 : 반환타입이 Member로 명확함
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);

List<Member> resultList = query.getResultList();
for(Member member : resultList) {
    System.out.println("member = " + member);
}

// Query 사용: 반환 타입이 String username, Integer age로 명확하지 않음
Query query = em.createQuery("SELECT m.username, m.age from Member m");
List resultList = query.getResultList();

for(Object o : resultList) {
    Object[] result = (Object[]) o; // 결과가 둘 이상이면 Object[] 반환
}
```

두 코드를 비교해보면 타입을 변환할 필요가 없는 TypeQuery를 사용하는 것이 더 편리한 것을 알 수 있다.

- `getResultList()`, `getSingleResultList()`: 쿼리를 실행해서 데이터베이스 조회 결과를 반환
-  `getResultList()`: 결과가 하나 이상일 때 리스트를 반환하며, 결과가 없다면 빈 리스트를 반환
- `getSingleResultList()`: 단일 객체를 반환하며, 결과가 정확히 1개가 아니면 예외가 발생한다

<br>

## 10.2.2 파라미터 바인딩

- 파라미터 바인딩(Parameter Binding)은 쿼리 안에 값을 직접 넣지 않고, 외부에서 값을 주입해서 사용하는 방식이다
- 2가지 바인딩 방식이 있다 → :name 또는 ?1 같은 **기호로 변수화한 뒤, `setParameter()`로 값을 주입**한다.
  - 이름 기반(named parameter): :name, :age 이런 식으로 이름을 붙여줌 
  - 위치 기반(positional parameter): ?1, ?2 이런 식으로 순서에 따라 값을 넣음
- 이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확하다

```JAVA
// 이름 기반
SELECT m FROM Member m where m.username=:username
query.setParameter("username", usernameParam);
```

```JAVA
// 위치 기반
SELECT m FROM Member m where m.username=?1
query.setParameter(1, usernameParam);
```

<br>

## 10.2.3 프로젝션

- 프로젝션: SELECT절에 조회할 대상을 지정하는 것 
- 프로젝션 대상: 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자등 기본 데이터 타입)
  - 중복 제거 시 DISTINCT 사용

### 엔티티 프로젝션

```JAVA
// Member 조회
List<Member> result = em.createQuery("SELECT m FROM Member m", Member.class).getResultList();
```
- 결과는 영속성 컨텍스트에서 관리됨 (변경 감지 가능)

```JAVA
// Member과 연관된 team 조회
List<Team> result = em.createQuery("SELECT m.team FROM Member m", Team.class).getResultList();
```
- 위의 경우 조인이 내부적으로 일어나지만(inner join), 혼동 방지 위해 명시적 조인 권장됨 (SELECT t FROM Member m JOIN m.team t)

### 임베디드 타입 프로젝션

```JAVA
List<Address> addresses = em.createQuery("SELECT m.address FROM Member m", Address.class).getResultList();
```
- 임베디드 타입은 단독으로 존재하지 않고, 항상 엔티티에 포함되어야 함(m.address)
- 엔티티 타입이 아니라 값 타입이므로, 결과는 영속성 컨텍스트에서 관리되지 않음

### 스칼라 타입 프로젝션

- 스칼라 타입: 숫자, 문자, 날짜와 같은 기본 데이터 타입

```JAVA
List<String> usernames = em.createQuery("SELECT username FROM Member m", String.class).getResultList();
```

### 여러 값 조회

```JAVA
List<Object[]> result = em.createQuery("SELECT m.username, m.age FROM Member m").getResultList();
```

- 여러 필드를 그냥 배열로 담아서 가져오는 방식으로, 인덱스로 꺼내는 부분이나 형변환 하는 부분이 불편함

```JAVA
Object[] row = result.get(0);
String username = (String) row[0];
Integer age = (Integer) row[1];
```

### NEW 명령어 (DTO로 조회)

```JAVA
List<UserDTO> result = em.createQuery(
                "SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m",
                UserDTO.class
        ).getResultList();
```

- JPA가 쿼리 결과로 바로 DTO 객체를 만들어주는 방식으로, 코드가 깔끔함
- UserDTO 클래스에 생성자 필요
- 패키지 포함한 전체 경로 필요

<br>

## 10.2.4 페이징 API

JPA는 페이징을 다음 두 API로 추상화한다.

- setFirstResult(int startPosition) : 조회 시작 위치 (0부터 시작)
- setMaxResults(int maxResult) : 조회할 데이터 수

```JAVA
String jpql = "select m from Member m order by m.age desc";
List<Member> resultList = em.createQuery(jpql, Member.class)
        .setFirstResult(1)
        .setMaxResults(10)
        .getResultList();
```
age를 기준으로 내림차순 정렬하고 있으며, 2번째(0에서 시작이므로)부터 11번째까지(10개 가져옴)의 데이터를 가져온다는 의미이다.

- DB마다 페이징 처리 SQL 문법이 다르다.
  - MYSQL: LIMIT 사용
  - ORACLE: ROWNUM 사용

<br>

## 10.2.5 집합과 정렬

Aggression 함수(COUNT, AVG, MAX, MIN 등)와 GROUP BY, HAVING, ORDER BY 에 대한 얘기가 나오는데 아는 얘기라 스킵한다. 

<br>

## 10.2.6 JPQL 조인

- SQL 조인과 기능은 같고 문법이 약간 다르다

### 내부 조인

```JAVA
SELECT m FROM Member m INNER JOIN m.team t WHERE t.name = :teamName
```
- INNER 생략 가능
- SQL에서는 조인을 할 때 ON 절을 통해 외래키와 기본키의 일치 조건을 명시해야 하지만, JPQL에서는 연관 필드(m.team) 를 통해 자동으로 조인 조건을 처리함
  - SQL
  ```SQL
  SELECT m.* 
  FROM Member m
  INNER JOIN Team t ON m.team_id = t.id
  WHERE t.name = ?
  ```

### 외부 조인

```JAVA
SELECT m FROM Member m LEFT JOIN m.team t
```
- OUTER 생략 가능

### 컬렉션 조인

```JAVA
SELECT t, m FROM Team t LEFT JOIN t.members m
```
- t.members는 Team 엔티티가 가지고 있는 일대다(`@OneToMany`) 컬렉션 연관 필드
- JPQL에서는 일대다 관계(+ 일대다로 풀어써야하지만 다대다 관계)에서 컬렉션 값 연관 필드를 사용해서 조인을 간단하게 표현할 수 있다

### 세타 조인

```JAVA
SELECT m FROM Member m, Team t WHERE m.username = t.name
```
- **연관 없는 엔티티끼리 조인 가능** : 여기서는 m.username, t.name
- 내부 조인만 가능

### ON 절 (JPA 2.1+ 지원)

```JAVA
SELECT m, t FROM Member m LEFT JOIN m.team t ON t.name = 'A'
```
- ON절 사용 시 조인 대상을 필터링 하고 조인 가능: 여기서는 t.name = 'A'로 조인 시점에 조인 대상 필터링
- 내부 조인의 ON절은 WHERE절을 사용할 때와 결과 동일하므로, ON절은 보통 외부 조인에서만 사용

<br>

## 10.2.7 페치 조인

- 페치 조인이란, SQL에서 얘기하는 조인의 종류는 아니고 JPQL에서 성능 최적화를 위해 제공하는 기능
- 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능
- join fetch 명령어로 사용 가능

### 엔티티 페치 조인

```JAVA
SELECT m FROM Member m JOIN FETCH m.team
```
- 연관된 팀까지 한 번에 조회 (지연 로딩 무시됨)

### 컬렉션 페치 조인

```JAVA
SELECT t FROM Team t JOIN FETCH t.members WHERE t.name = '팀A'
```
- 결과가 중복될 수 있음 → DISTINCT로 해결

### 페치 조인과 DISTINCT

```JAVA
SELECT DISTINCT t FROM Team t JOIN FETCH t.members
```
- SQL + 애플리케이션 레벨 중복 제거

### 페치 조인과 일반 조인의 차이

- 일반 조인: 조인은 하지만, select 절에는 지정된 엔티티만 조회함 → 연관된 필드는 여전히 지연 로딩이 적용되어, 실제 접근 시 쿼리가 나감 / 즉시 로딩이라면, 로딩을 위해 쿼리가 한 번 더 나감
- 페치 조인: 조인을 하면서 연관된 엔티티까지 즉시 로딩함 → 즉, 쿼리 한 번으로 연관 엔티티도 메모리에 로딩됨

### 페치 조인의 특징 및 한계 

- 별칭 사용 불가 
- 컬렉션 두 개 이상 페치 불가 
- 컬렉션 페치 시 페이징 불가

<br>

## 10.2.8 경로 표현식

- 경로 표현식: 객체 그래프를 탐색할 때 .(점)을 찍어서 안으로 들어가는 방식

| 종류              | 설명                                                    | 탐색 가능 여부 |
|-------------------|-------------------------------------------------------|--------------|
| 상태 필드         | 나이, 이름 등 단순히 값을 저장하기 위한 필드                            | ❌ | 
| 단일 값 연관 필드 | 연관관계를 맺기 위해 사용하는 필드. @ManyToOne, @OneToOne, 대상이 엔티티   | ✅ |
| 컬렉션 연관 필드  | 연관관계를 맺기 위해 사용하는 필드. @OneToMany, @ManyToMany, 대상이 컬렉션 | ❌ |

### 탐색 가능 여부 

- 상태 필드: 숫자, 문자열 같은 기본 값. 탐색은 여기서 끝. 
- 단일 값 연관 필드: 다른 엔티티 하나와 연결됨 → 점 찍고 더 탐색 가능 → 이때 자동으로 묵시적 조인 발생 
  - 묵시적 (내부) 조인: JOIN이란 말을 직접 안 써도, JPQL이 자동으로 INNER JOIN 해주는 것
  - 조인이 언제 일어나는지 명확하게 드러나는 **명시적 조인이 권장**됨
- 컬렉션 값 연관 필드: 여러 엔티티와 연결됨 → 더 이상 탐색 못함 → **명시적으로 JOIN 해서 별칭을 얻어야 탐색 가능**

```JAVA
@Entity
public class Member {
  @Id @GeneratedValue
  private Long id;

  private String username;  // 상태 필드
  private Integer age;      // 상태 필드

  @ManyToOne
  private Team team;        // 단일 값 연관 필드

  @OneToMany
  private List<Order> orders; // 컬렉션 값 연관 필드
}
```

```JAVA
SELECT m.username FROM Member m      -- 상태 필드 → 끝
SELECT m.team.name FROM Member m     -- 단일 연관 필드 → 계속 탐색 가능
SELECT m.orders FROM Member m        -- 컬렉션 연관 필드 → 끝
SELECT o.productName FROM Member m JOIN m.orders o      -- m.orders o로 별칭을 얻었으므로, 별칭 o부터 다시 경로 탐색 가능
```

<br>

## 10.2.9 서브 쿼리

- JPQL에선 서브 쿼리를 WHERE, HAVING 절에서만 사용할 수 있다
- JPQL은 FROM절에 서브쿼리를 넣을 수 없다
- JPQL에서 기본적으로는 SELECT절에서 서브쿼리 사용 불가하나, 하이버네이트는 추가적으로 SELECT 절의 서브 쿼리도 허용한다
- JPQL에서 EXISTS, IN, ALL, ANY, SOME 같은 표준 SQL 함수도 사용 가능

<br>

## 10.2.10 조건식

마찬가지로, SQL과 유사하니 차이점 위주로 서술하겠다. 

- 컬렉션 식: 
  - IS [NOT] EMPTY: 컬렉션이 비었는지
  - [NOT] MEMBER OF: 특정엔티티나 값이 컬렉션이 포함되었는지
- 엔티티 타입 비교: TYPE(엔티티)
- ENUM 비교: Enum 비교 시 패키지명 포함한 전체 경로 필요 (ex. com.app.Role.USER)

```JAVA
-- 컬렉션이 비었는지
SELECT t FROM Team t WHERE t.members IS EMPTY

-- 특정 회원이 팀에 포함되는지
SELECT t FROM Team t WHERE :memberParam MEMBER OF t.members

-- 타입 비교
SELECT i FROM Item i WHERE TYPE(i) = Book

```

<br>

## 10.2.11 다형성 쿼리

- JPQL로 부모 엔티티를 조회하면 그 자식 엔티티도 함께 조회한다

#### TYPE
TYPE은 엔티티의 상속 구조에서 조회 대상을 특정 자식 타입으로 한정할 때 주로 사용한다.
`select i from Item i where type(i) IN (Book, Movie)`

#### TREAT(JPA 2.1)
TREAT는 JPA 2.1에 추가된 기능인데 자바의 타입 캐스팅과 비슷하다.  
상속 구조에서 부모 타입을 특정 자식타입으로 다룰 때 사용한다.
`select i from Item i where treat(i as Book).author = 'kim'`

<br>

## 10.2.12 사용자 정의 함수 호출(JPA 2.1+)

JPA 2.1부터 사용자 정의 함수를 지원한다. 하이버네이트 사용 시, 방언 클래스를 상속해서 구현하고 사용할 데이터베이스 함수를 미리 등록해야놔야 한다. 

`<property name="hibernate.dialect" value="hello.MyH2Dialect" />`

``` java
public class MyH2Dialect extends H2Dialect {
    public MyH2Dialect() {
        registerFunction( "group_concat", new StandardSQLFunction
            ("group_concat", StandardBasicTypes.STRING));
    }
}
```

<br>

## 10.2.13 기타 정리

- enum은 = 비교 연산만 지원한다
- 임베디드 타입은 비교를 지원하지 않는다

<br>

## 10.2.14 엔티티 직접 사용

- JPQL에서 엔티티를 직접 조건에 넣을 수 있는데, 내부적(SQL)으로는 키 값으로 비교가 일어난다

### 기본 키 기준 비교

``` java
String ql = "SELECT m FROM Member m WHERE m = :member";
```

내부적으로 m = :member(객체) → m.id = :member.id처럼 변환된다. SQL에서는 WHERE m.id = ?처럼 기본 키(id) 기준으로 비교된다. 

### 외래 키 기준 비교

``` java
String ql = "SELECT m FROM Member m WHERE m.team = :team";
```
연관된 엔티티를 비교하면 외래 키 기준으로 비교가 된다. 즉, 위의 상황에서 내부적으로는 m.team_id = ?처럼 외래 키(team_id) 기준으로 비교된다.

<br>

## 10.2.15 Named 쿼리: 정적 쿼리

### 동적쿼리 vs. 정적쿼리

| 구분       | 설명                                              | 예시                                |
|------------|---------------------------------------------------|-------------------------------------|
| 동적 쿼리  | 실행할 때 JPQL 문자열을 직접 만들어서 실행         | `em.createQuery("SELECT ...")`      |
| 정적 쿼리  | 미리 정의한 쿼리에 이름을 붙여 재사용              | `@NamedQuery`, XML                  |

### 애노테이션 방식

``` java
@Entity
@NamedQuery(
  name = "Member.findByUsername",
  query = "SELECT m FROM Member m WHERE m.username = :username"
)
public class Member {}

// 사용
List<Member> result = em.createNamedQuery("Member.findByUsername", Member.class)
    .setParameter("username", "회원1")
    .getResultList();

```
- `@NamedQuery`, `@NamedQueries` 붙이기

### XML 방식 (선호)

``` XML
<?xml version="1.0" encoding="UTF-8"?>
<entity-mappings xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm" version="2.1">
    <named-query name="Member.findByUsername">
        <query>
          <CDATA[
            select m
            from Member m
            where m.username = :username
            ]></query>
    </named-query>
    
    <named-query name="Member.count">
        <query>select count(m) from Member m</query>
    </named-query>
    
</entity-mappings>
```

ormMember.xml을 인식하도록 META-INF/persistence.xml에 다음 코드를 추가한다.

```xml
<persistence-unit name="jpabook" >
    <mapping-file>META-INF/ormMember.xml</mapping-file>
</persistence-unit>
```

<br>
<br>

# 10.3 Criteria

- JPQL과 내용이 많이 중복되고, Criteria 사용은 권장되지 않으므로 생략한다.